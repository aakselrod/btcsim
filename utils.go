/*
 * Copyright (c) 2014-2015 Conformal Systems LLC <info@conformal.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package main

import (
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"time"

	"github.com/btcsuite/btcutil"
	"gopkg.in/yaml.v2"
)

// SimCommand represents a single command in the CSV file and holds
// all of the arguments (though some may be nil, depending on command).
type SimCommand struct {
	Cmd      string
	Name     string `yaml:omitempty`
	Name2    string `yaml:omitempty`
	StrArg   string `yaml:omitempty`
	Template string `yaml:omitempty`
	Var      string `yaml:omitempty`
	Num      uint32 `yaml:omitempty`
	Num2     uint32 `yaml:omitempty`
}

// readYAML reads the given filename and returns a slice of commands
func readYAML(simFilePath string) ([]SimCommand, error) {
	var commands []SimCommand
	yamlBytes, err := ioutil.ReadFile(simFilePath)
	if err != nil {
		return nil, err
	}
	err = yaml.Unmarshal(yamlBytes, &commands)
	if err != nil {
		return nil, err
	}
	return commands, nil
}

func getLogFile(prefix string) (*os.File, error) {
	return os.Create(filepath.Join(AppDataDir, fmt.Sprintf("%s.log", prefix)))
}

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string) error {
	org := "btcsim autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0666); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	return nil
}

// filesExists reports whether the named file or directory exists.
func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

// getUnusedPort returns a local port that isn't listening but can't guarantee
// that after the function returns, no other process will have bound to it.
func getUnusedPort() (uint16, error) {
	listener, err := net.Listen("tcp4", "127.0.0.1:0")
	if err != nil {
		return 0, err
	}
	port := uint16(listener.Addr().(*net.TCPAddr).Port)
	err = listener.Close()
	return port, err
}
